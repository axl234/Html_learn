<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>CanvasRender 全景图</title>
    <script src="../lib/three.js"></script>
    <script src="../lib/three-projector.js"></script>
    <script src="../lib/three-canvas-render.js"></script>
    <style type="text/css">
        body{
            padding:0;
            margin:0;
        }
        div#canvas-frame {
            cursor: pointer;
            width:100%;
            height:100%;
            background-color: #EEEEEE;
        }
    </style>
</head>
<body onload="threeStart();">
    <div id="canvas-frame"></div>
    <script>
        var renderer;
        var width;
        var height;
        var target = new THREE.Vector3();

        window.requestAnimFrame = (function() {//如果有变化则可能还需要requestAnimationFrame刷新
            return window.requestAnimationFrame ||
                    window.mozRequestAnimationFrame ||
                    window.webkitRequestAnimationFrame ||
                    window.msRequestAnimationFrame ||
                    window.webkitRequestAnimationFrame;
        })();

        function initThree() {
            width = window.innerWidth;
            height = window.innerHeight;
            //创建渲染器
            renderer = new THREE.CanvasRenderer();
            renderer.setPixelRatio( window.devicePixelRatio );
            renderer.setSize(width, height);
            //并添加容器中
            document.getElementById('canvas-frame').appendChild(renderer.domElement);
        }

        var camera;
        function initCamera() {
            //创建相机
            camera = new THREE.PerspectiveCamera( 60, width / height, 1, 2000 );
        }

        var scene;
        function initScene() {
            //创建场景
            scene = new THREE.Scene();
        }

        var light;
        function initLight() {
            //创建光线
        }

        /**
         * 图片纹理之间存在小间隙，暂时不知道咋解决。
         * /
        var texture_placeholder;//默认纹理
        function initObject(){
            texture_placeholder = document.createElement( 'canvas' );
            texture_placeholder.width = 1024;
            texture_placeholder.height = 1024;
            var context = texture_placeholder.getContext( '2d' );
            context.fillStyle = 'rgb( 200, 200, 200 )';
            context.fillRect( 0, 0, texture_placeholder.width, texture_placeholder.height );

            var materials = [
                loadTexture( 'textures/park-panorama-cube-nx.jpg' ),
                loadTexture( 'textures/park-panorama-cube-x.jpg' ),

                loadTexture( 'textures/park-panorama-cube-y.jpg' ),
                loadTexture( 'textures/park-panorama-cube-ny.jpg' ),

                loadTexture( 'textures/park-panorama-cube-z.jpg' ),
                loadTexture( 'textures/park-panorama-cube-nz.jpg' )
            ];

            var mesh = new THREE.Mesh( new THREE.BoxGeometry( 300, 300, 300, 7, 7, 7 ), materials );
            mesh.scale.x = - 1;
            scene.add( mesh );
        }

        //加载图片纹理
        function loadTexture( path ) {
            var texture = new THREE.Texture( texture_placeholder );
            var material = new THREE.MeshBasicMaterial( { map: texture, overdraw: 0.5 } );
            var image = new Image();
            image.onload = function () {
                texture.image = this;
                texture.needsUpdate = true;
            };
            image.src = path;
            return material;
        }

        function render(){
            //渲染
            updateTarget(lat,lon);
            camera.lookAt( target );
            renderer.render(scene, camera);
            window.requestAnimFrame(render);
        }

        function threeStart() {
            initThree();
            initCamera();
            initScene();
            initLight();
            initObject();
            render();

            //鼠标操作
            document.addEventListener( 'mousedown', onDocumentMouseDown, false );

            //触摸操作
            document.addEventListener( 'touchstart', onDocumentTouchStart, false );
            document.addEventListener( 'touchmove', onDocumentTouchMove, false );
        }

        /**
         * 根据垂直和水平方向相对初始位置移动的角度更新视线焦点位置
         * @param lat
         * @param lon
         */
        function updateTarget(lat,lon){
            lat = Math.max( - 85, Math.min( 85, lat ) );//控制垂直方向的移动角度
            var phi = THREE.Math.degToRad( lat );
            var theta = THREE.Math.degToRad( lon );

            /**
             * 计算原理请参考《聊一聊全景图》；
             * https://newbieweb.lione.me/2017/10/15/%E8%81%8A%E4%B8%80%E8%81%8A%E5%85%A8%E6%99%AF%E5%9B%BE/
             */
            target.x = Math.cos( phi ) * Math.sin( theta );
            target.y = Math.sin( phi );
            target.z = Math.cos( phi ) * Math.cos( theta );

            camera.lookAt( target );
        }

        //事件相关
        var lon = 0;
        var lat = 0;
        var touchX,touchY;

        //鼠标事件相关
        function onDocumentMouseDown(event){
            event.preventDefault();

            document.addEventListener( 'mousemove', onDocumentMouseMove, false );
            document.addEventListener( 'mouseup', onDocumentMouseUp, false );
        }

        function onDocumentMouseMove(event){
            var movementX = event.movementX || event.mozMovementX || event.webkitMovementX || 0;
            var movementY = event.movementY || event.mozMovementY || event.webkitMovementY || 0;

            lon += movementX * 0.1;
            lat += movementY * 0.1;
        }

        function onDocumentMouseUp( event ) {
            document.removeEventListener( 'mousemove', onDocumentMouseMove );
            document.removeEventListener( 'mouseup', onDocumentMouseUp );
        }

        //触摸操作
        function onDocumentTouchStart(event){
            //event.preventDefault();
            var touch = event.touches[ 0 ];
            touchX = touch.screenX;
            touchY = touch.screenY;
        }
        function onDocumentTouchMove(event){
            //event.preventDefault();
            var touch = event.touches[ 0 ];

            lon += ( touch.screenX - touchX ) * 0.1;
            lat += ( touch.screenY - touchY ) * 0.1;

            touchX = touch.screenX;
            touchY = touch.screenY;
        }
    </script>
</body>
</html>