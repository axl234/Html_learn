<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>WebGL简单实现高斯模糊</title>
    <script type="text/javascript" src="./sim-tools.js"></script>
</head>
<body onload="main()">
<canvas id="webgl" width="256" height="256"></canvas>
<!-- 片段着色器程序 -->
<script id="shader-fs" type="x-shader/x-fragment">
        precision highp float;
        varying vec2 v_TexCoord;
        uniform sampler2D u_Sampler;//纹理取样器
        uniform vec2 v_Blur;

        //关于这个高斯模糊算法为什么要采用多重处理，主要是因为分为纵横二次处理，某个点的颜色会被以其为原点的坐标系的x和y轴上的点影响，但是如果单次处理，某个点的颜色则只会被过该点以及坐标系的一、三象限的对角线上的点影响。
        void main(void) {
            gl_FragColor = vec4(0.0);
            gl_FragColor += texture2D(u_Sampler, v_TexCoord + vec2(-7.0*v_Blur.x, -7.0*v_Blur.y))*0.0044299121055113265;
            gl_FragColor += texture2D(u_Sampler, v_TexCoord + vec2(-6.0*v_Blur.x, -6.0*v_Blur.y))*0.00895781211794;
            gl_FragColor += texture2D(u_Sampler, v_TexCoord + vec2(-5.0*v_Blur.x, -5.0*v_Blur.y))*0.0215963866053;
            gl_FragColor += texture2D(u_Sampler, v_TexCoord + vec2(-4.0*v_Blur.x, -4.0*v_Blur.y))*0.0443683338718;
            gl_FragColor += texture2D(u_Sampler, v_TexCoord + vec2(-3.0*v_Blur.x, -3.0*v_Blur.y))*0.0776744219933;
            gl_FragColor += texture2D(u_Sampler, v_TexCoord + vec2(-2.0*v_Blur.x, -2.0*v_Blur.y))*0.115876621105;
            gl_FragColor += texture2D(u_Sampler, v_TexCoord + vec2(-1.0*v_Blur.x, -1.0*v_Blur.y))*0.147308056121;
            gl_FragColor += texture2D(u_Sampler, v_TexCoord                             )*0.159576912161;
            gl_FragColor += texture2D(u_Sampler, v_TexCoord + vec2( 1.0*v_Blur.x,  1.0*v_Blur.y))*0.147308056121;
            gl_FragColor += texture2D(u_Sampler, v_TexCoord + vec2( 2.0*v_Blur.x,  2.0*v_Blur.y))*0.115876621105;
            gl_FragColor += texture2D(u_Sampler, v_TexCoord + vec2( 3.0*v_Blur.x,  3.0*v_Blur.y))*0.0776744219933;
            gl_FragColor += texture2D(u_Sampler, v_TexCoord + vec2( 4.0*v_Blur.x,  4.0*v_Blur.y))*0.0443683338718;
            gl_FragColor += texture2D(u_Sampler, v_TexCoord + vec2( 5.0*v_Blur.x,  5.0*v_Blur.y))*0.0215963866053;
            gl_FragColor += texture2D(u_Sampler, v_TexCoord + vec2( 6.0*v_Blur.x,  6.0*v_Blur.y))*0.00895781211794;
            gl_FragColor += texture2D(u_Sampler, v_TexCoord + vec2( 7.0*v_Blur.x,  7.0*v_Blur.y))*0.0044299121055113265;
        }
</script>
<!-- 顶点着色器程序 -->
<script id="shader-vs" type="x-shader/x-vertex">
		attribute vec4 a_Position;//顶点坐标
		attribute vec2 a_TexCoord;//纹理坐标
		varying vec2 v_TexCoord;
	    void main() {
	        gl_Position= a_Position;
            v_TexCoord = a_TexCoord;
	    }
</script>
<script>
    var blur;
    var v_Blur;
    var canvas;

    function main(){
        canvas = document.querySelector('#webgl');
        var gl = canvas.getContext('webgl');//获取canvas上下文
        var shaderPorgram = initShaders(gl);//初始化着色器程序
        blur = {x:10/7/canvas.width,y:10/7/canvas.height};

        v_Blur = gl.getUniformLocation(shaderPorgram, 'v_Blur');

        var num = initVertexBuffers(gl,shaderPorgram);

        //gl.clearColor(1.0,1.0,1.0,1.0);//白色背景色
        gl.clearColor(0.0,0.0,0.0,1.0);//黑色背景色

        // Set texture
        if (!initTextures(gl,shaderPorgram, num)) {
            console.log('Failed to intialize the texture.');
            return;
        }
    }

    var _createFramebufferTexture = function(gl) {
        var fbo = gl.createFramebuffer();
        gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);

        var renderbuffer = gl.createRenderbuffer();
        gl.bindRenderbuffer(gl.RENDERBUFFER, renderbuffer);

        var texture = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, texture);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, canvas.width, canvas.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);

        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);

        gl.bindTexture(gl.TEXTURE_2D, null);
        gl.bindFramebuffer(gl.FRAMEBUFFER, null);

        return {fbo: fbo, texture: texture};
    };

    //初始化纹理
    function initTextures(gl,shaderPorgram,n){
        var texture = gl.createTexture();//创建纹理对象

        if(!texture){
            console.log('Failed to create the texture object!');
            return false;
        }

        var u_Sampler = gl.getUniformLocation(shaderPorgram,'u_Sampler');
        var image = new Image();
        image.src = '../img/sky.JPG';
        image.onload = function(){
            loadTextures(gl,n,texture,u_Sampler,image);
        }
        return true;
    }

    //加载纹理图片
    function loadTextures(gl,n,texture,u_Sampler,image){
        gl.clear(gl.COLOR_BUFFER_BIT);   // Clear <canvas>

        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, 1);//对纹理图像进行y轴反转
        gl.bindTexture(gl.TEXTURE_2D, texture);//绑定纹理对象

        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);//配置纹理对象的参数
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        /**
         * 使用NEAREST过滤器的纹理始终会返回最接近样本点的马赛克（texel）中心点的颜色，
         * 使用LINEAR过滤器返回以样本点为中心四个方向上像素的平均值，这会形成一个逐渐过渡的颜色，这效果通常也是更理想的，但是这也意味着显卡需要消耗四倍的工作量。
         */
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);

        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGB, gl.RGB, gl.UNSIGNED_BYTE, image);//将纹理图像分配给纹理对象

        // Vertical
        gl.uniform2f(v_Blur, 0, blur.y);
        var fbt = _createFramebufferTexture(gl);
        gl.bindTexture(gl.TEXTURE_2D, texture);
        gl.bindFramebuffer(gl.FRAMEBUFFER, fbt.fbo);
        gl.drawArrays(gl.TRIANGLE_STRIP, 0, n);

        // Horizontal
        gl.uniform2f(v_Blur, blur.x, 0);
        gl.bindTexture(gl.TEXTURE_2D, fbt.texture);
        gl.bindFramebuffer(gl.FRAMEBUFFER, null);
        gl.drawArrays(gl.TRIANGLE_STRIP, 0, n);
    }

    //初始化顶点位置
    function initVertexBuffers(gl,shaderPorgram){
        //顶点坐标和纹理坐标映射关系
        var datas = new Float32Array([
            //顶点坐标、纹理坐标
            -1.0,1.0,0.0,1.0,
            -1.0,-1.0,0.0,0.0,
            1.0,1.0,1.0,1.0,
            1.0,-1.0,1.0,0.0,
        ]);

        var num = 4;//顶点数目
        var vertexBuffer = gl.createBuffer();//创建缓冲区对象

        if(!vertexBuffer){
            console.log('Failed to create the buffer object!');
            return -1;
        }

        //将缓冲区对象绑定到目标并写入数据
        gl.bindBuffer(gl.ARRAY_BUFFER,vertexBuffer);
        gl.bufferData(gl.ARRAY_BUFFER,datas,gl.STATIC_DRAW);

        var size = datas.BYTES_PER_ELEMENT;//数组中的每个元素的大小（以字节为单位）

        //顶点着色器接受顶点坐标和纹理坐标映射关系
        var a_Position = gl.getAttribLocation(shaderPorgram,'a_Position');
        gl.vertexAttribPointer(a_Position,2,gl.FLOAT,false,size*4,0,0);
        gl.enableVertexAttribArray(a_Position);

        var a_TexCoord = gl.getAttribLocation(shaderPorgram,'a_TexCoord');
        gl.vertexAttribPointer(a_TexCoord,2,gl.FLOAT,false,size*4,size*2);
        gl.enableVertexAttribArray(a_TexCoord);

        return num;
    }
</script>
</body>
</html>