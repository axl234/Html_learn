<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>这可能是地球上最美的H5-模仿</title>
    <script type="text/javascript" src="../lib/three.js"></script>
    <script type="text/javascript" src="../lib/three-orbit-controls.js"></script>
    <style type="text/css">
        div#canvas-frame {
            position: absolute;
            top:0;
            left:0;
            cursor: pointer;
            width:100%;
            height:100%;
        }
        .star-bg{
            position: absolute;
            top:0;
            left:0;
            width:100%;
            height:100%;
            background:#0c0604 url(./textures/star-bg.jpg) no-repeat center;
            background-size:cover;
            background-position: 50% 50%;
            overflow:hidden;
        }
    </style>
</head>
<body onload="threeStart();">
    <div class="star-bg">
        <div id="canvas-frame"></div>
    </div>
<script>
    var renderer;//渲染器
    var width;//页面宽度
    var height;//页面高度
    var controller;
    window.requestAnimFrame = (function() {//如果有变化则可能还需要requestAnimationFrame刷新
        return window.requestAnimationFrame ||
                window.mozRequestAnimationFrame ||
                window.webkitRequestAnimationFrame ||
                window.msRequestAnimationFrame ||
                window.webkitRequestAnimationFrame;
    })();
    //开始
    function threeStart() {
        initThree();
        initCamera();
        initScene();
        initLight();
        initObject();
        render();
    }
    //根据页面宽度和高度创建渲染器，并添加容器中
    function initThree() {
        width = window.innerWidth;
        height = window.innerHeight;
        renderer = new THREE.WebGLRenderer({
            antialias : true
        });
        renderer.setSize(width, height);
        //如果设置了clearColor则会存在背景色遮挡页面的其他元素
        //renderer.setClearColor(0xFFFFFF, 1.0);
        document.getElementById('canvas-frame').appendChild(renderer.domElement);
    }
    //创建相机，并设置正方向和中心点
    var camera;
    function initCamera() {
        camera = new THREE.PerspectiveCamera(45, width / height, 1, 1000);
        camera.position.x = 0;
        camera.position.y = 0;
        camera.position.z = 600;
        camera.up.x = 0;//正方向
        camera.up.y = 1;
        camera.up.z = 0;
        camera.lookAt({
            x : 0,
            y : 0,
            z : 0
        });
        //视角控制
        controller = new THREE.OrbitControls(camera, renderer.domElement);
    }
    //创建场景，后续元素需要加入到场景中才会显示出来
    var scene;
    function initScene() {
        scene = new THREE.Scene();
    }
    //创建光线
    var directLight;
    function initLight() {
        directLight = new THREE.DirectionalLight(0xffffff);
        /**
         * 方向光的位置和物体的位置共同决定该方向光照射该物体的方向，
         * 也就是说如果物体位置在原点（0，0，0）那么方向光位置在（-1，0，0）或者（-80，0，0）对该物体而言意义一样。
         */
        directLight.position.set(-1,0,0);
        directLight.intensity = 1.5;
        scene.add(directLight);
    }
    //创建展示场景所需的各种元素
    function initObject() {
        //纹理
        var cloudTexture = THREE.ImageUtils.loadTexture('textures/earth_cloud.png');
        var mainTexture = THREE.ImageUtils.loadTexture('textures/earth_main.jpg');
        var normalTexture = THREE.ImageUtils.loadTexture('textures/earth_bump.jpg');
        var specTexture = THREE.ImageUtils.loadTexture('textures/earth_spec.jpg');

        //地球
        var earth_sphereGeometry = new THREE.SphereGeometry(120,40,40);
        var mainMaterial = new THREE.MeshPhongMaterial({
            map:mainTexture ,
            bumpMap: normalTexture ,
            bumpScale : .5,
            specularMap : specTexture,
            specular : new THREE.Color(0x909090),
            shininess : 1
        });
        //var earth = new THREE.Mesh( earth_sphereGeometry,mainMaterial );
        var earth = THREE.SceneUtils.createMultiMaterialObject(earth_sphereGeometry, [mainMaterial]);
        scene.add(earth);

        //云
        var cloud_sphereGeometry = new THREE.SphereGeometry(125,40,40);
        var cloudMaterial = new THREE.MeshPhongMaterial({
            map:cloudTexture ,
            transparent : true ,
            opacity : 1,
            color :  '#ffffff' ,
            blending : THREE.AdditiveBlending
        });
        // var cloud = new THREE.Mesh( earth_sphereGeometry,cloudMaterial );
        var cloud = THREE.SceneUtils.createMultiMaterialObject(cloud_sphereGeometry, [cloudMaterial]);
        scene.add(cloud);
    }
    //渲染
    function render(){
        renderer.clear();
        renderer.render(scene, camera);
        updateLightloaction();
        window.requestAnimFrame(render);
    }

    //更新光源位置，保证视角变化光源相对位置不变
    function updateLightloaction(){
        var theta =  controller.getPolarAngle()-Math.PI/2;
        var phi = controller.getAzimuthalAngle();
        directLight.position.set(-1, 0, 0);

        rotateAroundWorldY(directLight,phi);
        rotateAroundWorldX(directLight,theta);
    }

    //绕着世界坐标系的某个轴旋转
    function rotateAroundWorldY(obj,rad){
        var x0 = obj.position.x;
        var z0 = obj.position.z;
        /**
         * 因为物体本身的坐标系是随着物体的变化而变化的，
         * 所以如果使用rotateZ、rotateY、rotateX等方法，
         * 多次调用后就会出问题，先改为Quaternion实现。
         */
        var q = new THREE.Quaternion();
        q.setFromAxisAngle( new THREE.Vector3( 0, 1, 0 ), rad );
        obj.quaternion.premultiply( q );
        //obj.rotateY(rad);
        obj.position.x = Math.cos(rad)*x0+Math.sin(rad)*z0;
        obj.position.z = Math.cos(rad)*z0-Math.sin(rad)*x0;
    }
    function rotateAroundWorldZ(obj,rad){
        var x0 = obj.position.x;
        var y0 = obj.position.y;
        var q = new THREE.Quaternion();
        q.setFromAxisAngle( new THREE.Vector3( 0, 0, 1 ), rad );
        obj.quaternion.premultiply( q );
        //obj.rotateZ(rad);
        obj.position.x = Math.cos(rad)*x0-Math.sin(rad)*y0;
        obj.position.y = Math.cos(rad)*y0+Math.sin(rad)*x0;
    }
    function rotateAroundWorldX(obj,rad){
        var y0 = obj.position.y;
        var z0 = obj.position.z;
        var q = new THREE.Quaternion();
        q.setFromAxisAngle( new THREE.Vector3( 1, 0, 0 ), rad );
        obj.quaternion.premultiply( q );
        //obj.rotateX(rad);
        obj.position.y = Math.cos(rad)*y0-Math.sin(rad)*z0;
        obj.position.z = Math.cos(rad)*z0+Math.sin(rad)*y0;
    }
</script>
</body>
</html>