<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>ThreeJS ShaderMaterial</title>
    <script type="text/javascript" src="../lib/three.js"></script>
    <script type="text/javascript" src="../lib/Tween.js"></script>
    <script type="text/javascript" src="../lib/stats.min.js"></script>
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <style type="text/css">
        body{
            margin:0;
            padding:0;
        }
        div#canvas-frame {
            cursor: pointer;
            width:100%;
            height:100%;
            background-color: #EEEEEE;
        }
    </style>
</head>
<body onload="threeStart();">
<div id="canvas-frame"></div>
<script>
    'use strict';
    var renderer;//渲染器
    var width;//页面宽度
    var height;//页面高度
    var stats;//性能检测
    var pos = {val: 1};//动画运行进度
    window.requestAnimFrame = (function() {//如果有变化则可能还需要requestAnimationFrame刷新
        return window.requestAnimationFrame ||
                window.mozRequestAnimationFrame ||
                window.webkitRequestAnimationFrame ||
                window.msRequestAnimationFrame ||
                window.webkitRequestAnimationFrame;
    })();
    //开始
    function threeStart() {
        initThree();
        initCamera();
        initScene();
        initLight();
        initObject();
        render();
    }
    //根据页面宽度和高度创建渲染器，并添加容器中
    function initThree() {
        width = window.innerWidth;
        height = window.innerHeight;
        renderer = new THREE.WebGLRenderer();//ShaderMaterial只能在WebGLRenderer中渲染
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(width, height );
        var container = document.getElementById('canvas-frame');

        container.appendChild(renderer.domElement);

        stats = new Stats();
        container.appendChild( stats.dom );
    }
    //创建相机，并设置正方向和中心点
    var camera;
    function initCamera() {
        camera = new THREE.PerspectiveCamera(45, width / height, 1, 1000);
        camera.position.x = 0;
        camera.position.y = 0;
        camera.position.z = 600;
        camera.up.x = 0;//正方向
        camera.up.y = 1;
        camera.up.z = 0;
        camera.lookAt({
            x : 0,
            y : 0,
            z : 0
        });
    }
    //创建场景，后续元素需要加入到场景中才会显示出来
    var scene;
    function initScene() {
        scene = new THREE.Scene();
    }
    //创建光线
    var light;
    function initLight() {
        light = new THREE.AmbientLight(0xfefefe);
        scene.add(light);
    }
    //创建展示场景所需的各种元素
    var particleSystem;
    function initObject() {
        //起始坐标球
        var initGeometry = new THREE.SphereGeometry( 1, 32, 32 );
        var initBuffer = new THREE.BufferGeometry().fromGeometry(initGeometry);
        var initLength = initBuffer.attributes.position.array.length;
        var initColors = new Float32Array(initLength);
        var initSizes = new Float32Array(initLength);

        //最终坐标球
        var finalGeometry = new THREE.SphereGeometry(500, 32, 32);
        var finalBuffer = new THREE.BufferGeometry().fromGeometry(finalGeometry);
        var finalPosition = finalBuffer.attributes.position.array;
        var endPositions = new Float32Array(initLength);
        endPositions.set(finalPosition);

        for(var i=0;i<initLength;i++){
            initSizes[i] = Math.random().toFixed(1)*40;
            initColors[i] = Math.random().toFixed(1);
            endPositions[i] += Math.random()*100;//最终坐标增加适当随机变化，来保证最终效果不是一个很规则的球型
        }

        initBuffer.addAttribute('initColors',new THREE.BufferAttribute(initColors, 3));
        initBuffer.addAttribute('endPositions',new THREE.BufferAttribute(endPositions, 3));
        initBuffer.addAttribute('initSizes',new THREE.BufferAttribute(initSizes, 1));

        var shaderMaterial = new THREE.ShaderMaterial({
            uniforms: {
                val: { value: 1.0 },
                texture:{value: new THREE.TextureLoader().load( "./textures/dot2.png")}
            },
            vertexShader:   document.getElementById('vs').textContent,
            fragmentShader: document.getElementById('fs').textContent,
            depthTest:      false,
            transparent:    true
        });
        particleSystem = new THREE.Points(initBuffer, shaderMaterial);

        var tween = new TWEEN.Tween(pos).to({val: 0}, 1000).delay(500).onUpdate(callback);
        tween.start();
        function callback(){
            particleSystem.material.uniforms.val.value = pos.val;
        }
        scene.add(particleSystem);
    }
    //渲染
    function render(){
        renderer.clear();
        renderer.render(scene, camera);
        TWEEN.update();
        stats.update();
        window.requestAnimFrame(render);
    }
</script>
<script id="fs" type="x-shader/x-fragment">
    uniform sampler2D texture;
    varying vec3 vPos;
    varying vec3 vexcolor;
    void main() {
        vec3 vColor = vec3(1, 1, 1);
        gl_FragColor = vec4( vexcolor * vColor, 1.0 );
        gl_FragColor = gl_FragColor * texture2D( texture, gl_PointCoord );
    }
</script>
<script id="vs" type="x-shader/x-vertex">
    attribute float initSizes; // 粒子尺寸
    attribute vec3 endPositions; // 目标顶点位置
    attribute vec3 initColors; // 目标顶点颜色
    uniform float val; // 动画运行进度
    vec3 vPos; // 将顶点位置传输给片元着色器
    varying vec3 vexcolor;
    void main() {
        // 计算粒子位置
        vPos.x = endPositions.x * (1.-val);
        vPos.y = endPositions.y * (1.-val);
        vPos.z = endPositions.z * (1.-val);
        vexcolor.r = initColors.r;
        vexcolor.g = initColors.g;
        vexcolor.b = initColors.b;
        // 坐标转换
        // modelViewMatrix和projectionMatrix两个矩阵会交替处理后会把顶点坐标转换成最终的相机坐标系的顶点坐标
        vec4 mvPosition = modelViewMatrix * vec4( vPos, 1.0 );
        gl_PointSize = initSizes * (1.-val) * ( 300.0 / -mvPosition.z );
        gl_Position = projectionMatrix * mvPosition;
    }
</script>
</body>
</html>