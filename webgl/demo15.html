<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>简易太阳系</title>
    <script src="../lib/three.js"></script>
    <script src="../lib/three-orbit-controls.js"></script>
    <style type="text/css">
        body{
            margin:0;
            padding:0;
            overflow:hidden;
        }
        div#canvas-frame {
            cursor: pointer;
            width:100%;
            height:100%;
            background-color: #EEEEEE;
        }
    </style>
</head>
<body onload="threeStart();">
    <div id="canvas-frame"></div>
    <script>
        var renderer;//渲染器
        var width;//页面宽度
        var height;//页面高度

        window.requestAnimFrame = (function() {//如果有变化则可能还需要requestAnimationFrame刷新
            return window.requestAnimationFrame ||
                    window.mozRequestAnimationFrame ||
                    window.webkitRequestAnimationFrame ||
                    window.msRequestAnimationFrame ||
                    window.webkitRequestAnimationFrame;
        })();

        //开始
        function threeStart() {
            initThree();
            initCamera();
            initScene();
            initLight();
            initObject();
            render();
        }

        //根据页面宽度和高度创建渲染器，并添加容器中
        function initThree() {
            width = window.innerWidth;
            height = window.innerHeight;
            renderer = new THREE.WebGLRenderer({
                antialias : true
            });
            renderer.setSize(width, height);
            renderer.setClearColor(0xffffff, 0);
            document.getElementById('canvas-frame').appendChild(renderer.domElement);
        }

        //创建相机，并设置正方向和中心点
        var camera;
        var control;
        function initCamera() {
            camera = new THREE.PerspectiveCamera(45, width / height, 1, 3000);
            camera.position.x = 0;
            camera.position.y = 0;
            camera.position.z = 100;
            camera.up.x = 0;//正方向
            camera.up.y = 1;
            camera.up.z = 0;
            camera.lookAt({
                x : 0,
                y : 0,
                z : 0
            });

            //视角控制
            controller = new THREE.OrbitControls(camera, renderer.domElement);
            controller.target = new THREE.Vector3(0, 0, 0);//设置控制点
        }

        //创建场景，后续元素需要加入到场景中才会显示出来
        var scene;
        function initScene() {
            scene = new THREE.Scene();
        }

        //创建光线
        var ambient;
        var point;
        function initLight() {
            //环境光
            ambient = new THREE.AmbientLight(0x999999);
            scene.add(ambient);

            /*太阳光*/
            point = new THREE.PointLight(0xddddaa,1.5,500);
            scene.add(point);
        }

        //创建展示场景所需的各种元素
        var sun;
        var earth;
        var mars;
        var mercury;  //水星
        var venus;  //金星
        var jupiter; //木星
        var saturn; //土星
        var uranus; //天王
        var neptune; //海王
        function initObject() {
            var sunSkinPic = THREE.ImageUtils.loadTexture('/Html_learn/webgl/textures/sunCore.jpg', {}, function(){
                renderer.render(scene, camera);
            });//太阳自转为25天
            sun = new THREE.Mesh(new THREE.SphereGeometry(12,16,16),new THREE.MeshLambertMaterial({
                emissive:0xdd4422,
                map:sunSkinPic
            }))
            sun.name = 'Sun';
            sun.selfRotateSpeed = Math.PI/10/25;
            scene.add( sun );

            earth = initPlanet('Earth','rgb(46,69,119)',40,5,Math.PI/10/365,Math.PI/10/1,'/Html_learn/webgl/textures/land_ocean_ice_cloud_2048.jpg');//Math.PI*2/365
            mars = initPlanet('Mars','rgb(210,81,16)',50,4,Math.PI/10/365/1.88,Math.PI/10/1);//火星公转为1.88地球年，自转与地球相似
            mercury = initPlanet('Mercury','rgb(124,131,203)',20,2,Math.PI/10/88,Math.PI/10/59);//水星公转为88天，自转为59天
            venus = initPlanet('Venus','rgb(190,138,44)',30,4,Math.PI/10/225,-Math.PI/10/243);//金星公转为225天，自转为243天，且自转方向和地球相反
            jupiter = initPlanet('Jupiter','rgb(254,208,101)',70,9,Math.PI/10/4333,Math.PI/10/0.41);//木星公转为4333天，自转为0.41天
            saturn = initPlanet('Saturn','rgb(210,140,39)',100,7,Math.PI/10/10760,Math.PI/10/0.426);//土星公转为10760天，自转为0.426天
            uranus = initPlanet('Uranus','rgb(49,168,218)',120,4,Math.PI/10/30685,Math.PI/10/0.426);//天王星公转为30685天，自转为0.426天
            neptune = initPlanet('Neptune','rgb(84,125,204)',150,3,Math.PI/10/165,Math.PI/10/18/24);//海王星公转为165天，自转为18小时

            initStarBackground();
        }

        //星空背景
        function initStarBackground(){
            var particles = 20000;  //星星数量
            var bufferGeometry = new THREE.BufferGeometry();
            var positions = new Float32Array( particles * 3 );
            var colors = new Float32Array( particles * 3 );
            var color = new THREE.Color();
            var gap = 1000;//定义星星的最近出现位置

            for(var i=0;i<positions.length;i=i+3){
                //所有星星都出现在正负2000以内
                /*-2gap < x < 2gap */
                var x = ( Math.random() * gap *2 )* (Math.random()<.5? -1 : 1);
                var y = ( Math.random() * gap *2 )* (Math.random()<.5? -1 : 1);
                var z = ( Math.random() * gap *2 )* (Math.random()<.5? -1 : 1);

                /*找出x,y,z中绝对值最大的一个数*/
                var biggest = Math.abs(x) > Math.abs(y) ? Math.abs(x) > Math.abs(z) ?　'x' : 'z' :
                        Math.abs(y) > Math.abs(z) ? 'y' : 'z';

                var pos = {'x':x,'y':y,'z':z};

                //所有星星都出现在正负1000以外
                /*如果最大值比n要小（因为要在一个距离之外才出现星星）则赋值为n（-n）*/
                if(Math.abs(pos[biggest]) < gap) pos[biggest] = pos[biggest] < 0 ? -gap : gap;

                x = pos['x'];
                y = pos['y'];
                z = pos['z'];

                positions[ i ]     = x;
                positions[ i + 1 ] = y;
                positions[ i + 2 ] = z;

                /*70%星星有颜色*/
                var hasColor = Math.random() > 0.3;
                var vx, vy, vz;

                if(hasColor){
                    vx = (Math.random()+1) / 2 ;
                    vy = (Math.random()+1) / 2 ;
                    vz = (Math.random()+1) / 2 ;
                }else{
                    vx = 1 ;
                    vy = 1 ;
                    vz = 1 ;
                }

                color.setRGB( vx, vy, vz );

                colors[ i ]     = color.r;
                colors[ i + 1 ] = color.g;
                colors[ i + 2 ] = color.b;
            }

            bufferGeometry.addAttribute( 'position', new THREE.BufferAttribute( positions, 3 ) );
            bufferGeometry.addAttribute( 'color', new THREE.BufferAttribute( colors, 3 ) );
            bufferGeometry.computeBoundingSphere();

            /*星星的material*/
            var material = new THREE.PointsMaterial( { size: 6, vertexColors: THREE.VertexColors } );
            particleSystem = new THREE.Points( bufferGeometry, material );
            scene.add( particleSystem );
        }

        /**
         * 初始化行星
         * @param name 行星名字
         * @param color 颜色
         * @param distance 距离原点（太阳中心）的距离
         * @param volume 体积
         * @param speed 公转角速度
         * @param textureUrl 纹理路径
         */
        function initPlanet(name,color,distance,volume,speed,selfSpeed,textureUrl){
            var mesh = new THREE.Mesh(new THREE.SphereGeometry(volume,16,16),new THREE.MeshLambertMaterial( { color:color } ));
            if(textureUrl){
                var texture = THREE.ImageUtils.loadTexture(textureUrl, {}, function(){
                    renderer.render(scene, camera);
                });
                mesh = new THREE.Mesh(new THREE.SphereGeometry(volume,16,16),new THREE.MeshLambertMaterial( { map:texture } ));
            }
            mesh.position.z = -distance;
            mesh.castShadow = true;//辅助线
            mesh.receiveShadow = true;//柔和阴影
            mesh.name = name;
            mesh.aroundSunSpeed = speed;
            mesh.selfRotateSpeed = selfSpeed;
            mesh.radian = 0;
            scene.add(mesh);

            //轨道
            var track = new THREE.Mesh( new THREE.RingGeometry (distance-0.2, distance+0.2, 64,1),
                    new THREE.MeshBasicMaterial( { color: 0x888888, side: THREE.DoubleSide } )
            );
            track.rotation.x = - Math.PI / 2;
            scene.add(track);

            return mesh;
        }

        //绕世界坐标系Y轴旋转
        function rotateAroundWorldY(obj,rad){
            var x0 = obj.position.x;
            var z0 = obj.position.z;
            /**
             * 因为物体本身的坐标系是随着物体的变化而变化的，
             * 所以如果使用rotateZ、rotateY、rotateX等方法，
             * 多次调用后就会出问题，先改为Quaternion实现。
             */
            var q = new THREE.Quaternion();
            q.setFromAxisAngle( new THREE.Vector3( 0, 1, 0 ), rad );
            obj.quaternion.premultiply( q );
            //obj.rotateY(rad);
            obj.position.x = Math.cos(rad)*x0+Math.sin(rad)*z0;
            obj.position.z = Math.cos(rad)*z0-Math.sin(rad)*x0;
        }

        //矩阵方式实现绕世界坐标系Y轴旋转，但是不清楚为啥不能在render方法里边调用，不知道是不是OrbitControls控制器的原因
//        function rotateAroundWorldY(obj,rad){
//            var rad = 45*Math.PI/180;
//            var ry = new THREE.Matrix4();
//            ry.set(Math.cos(-rad),0,-Math.sin(-rad),0,
//                    0,1,0,0,
//                    Math.sin(-rad),0,Math.cos(-rad),0,
//                    0,0,0,1);
//            obj.applyMatrix(ry);
//        }

        //行星绕太阳公转
        function rotateAroundSun(){
            rotateAroundWorldY(earth,earth.aroundSunSpeed);
            rotateAroundWorldY(mars,mars.aroundSunSpeed);
            rotateAroundWorldY(mercury,mercury.aroundSunSpeed);
            rotateAroundWorldY(venus,venus.aroundSunSpeed);
            rotateAroundWorldY(jupiter,jupiter.aroundSunSpeed);
            rotateAroundWorldY(saturn,saturn.aroundSunSpeed);
            rotateAroundWorldY(uranus,uranus.aroundSunSpeed);
            rotateAroundWorldY(neptune,neptune.aroundSunSpeed);
        }

        //行星自转
        function rotateSelf(){
            sun.rotateY(sun.selfRotateSpeed);
            earth.rotateY(earth.selfRotateSpeed);
            mars.rotateY(mars.selfRotateSpeed);
            mercury.rotateY(mercury.selfRotateSpeed);
            venus.rotateY(venus.selfRotateSpeed);
            jupiter.rotateY(jupiter.selfRotateSpeed);
            saturn.rotateY(saturn.selfRotateSpeed);
            uranus.rotateY(uranus.selfRotateSpeed);
            neptune.rotateY(neptune.selfRotateSpeed);
        }

        //保证星空背景不出现异常显示情况
        function checkCamera(){
            if(!controller.enabled){
                controller.enabled = true;
            }
            var x = camera.position.x;
            var y = camera.position.y;
            var z = camera.position.z;
            if(Math.sqrt(x*x+y*y+z*z)>1000){
                controller.enabled = false;
                while(Math.sqrt(x*x+y*y+z*z)>1000){
                    camera.position.x = x*0.999;
                    camera.position.y = y*0.999;
                    camera.position.z = z*0.999;
                    x = camera.position.x;
                    y = camera.position.y;
                    z = camera.position.z;
                }
            }
        }

        //渲染
        function render(){
            renderer.clear();
            rotateAroundSun();
            rotateSelf();
            checkCamera();
            renderer.render(scene, camera);
            window.requestAnimFrame(render);
        }

    </script>
</body>
</html>