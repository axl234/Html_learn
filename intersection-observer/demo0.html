<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>intersection observer 异步观察目标元素</title>
    <style>
        .container{
            width:500px;
            height:500px;
            border:1px solid #000;
            overflow:scroll;
        }
        .container li{
            list-style: none;
            width:50px;
            height:50px;
            background-color:pink;
        }
        .container .item{
            background-color:blue;
        }
    </style>
</head>
<body>
    <ul class="container">
        <li></li>
        <li></li>
        <li></li>
        <li></li>
        <li></li>
        <li></li>
        <li></li>
        <li></li>
        <li></li>
        <li class="item"></li>
        <li></li>
        <li></li>
        <li></li>
        <li></li>
        <li></li>
        <li></li>
        <li></li>
        <li></li>
        <li></li>
        <li></li>
        <li></li>
    </ul>
    <script>
        window.onload = function(){
            var item = document.querySelector('.container .item');
            var io = new IntersectionObserver(function(entries){
                console.log(entries);
                /**
                 * time：可见性发生变化的时间，是一个高精度时间戳，单位为毫秒；
                 * target：被观察的目标元素，是一个 DOM 节点对象；
                 * rootBounds：根元素的矩形区域的信息，getBoundingClientRect()方法的返回值，如果没有根元素（即直接相对于视口滚动），则返回null；
                 * boundingClientRect：目标元素的矩形区域的信息；
                 * intersectionRect：目标元素与视口（或根元素）的交叉区域的信息；
                 * intersectionRatio：目标元素的可见比例，即intersectionRect占boundingClientRect的比例，完全可见时为1，完全不可见时小于等于0。
                 */
            },{
                /**
                 * threshold: 决定了什么时候触发回调函数，它是一个数组，每个成员都是一个门槛值，默认为[0]；
                 */
            });

            //开始观察
            io.observe(item)

            // 停止观察
            //io.unobserve($item);

            // 关闭观察器
            //io.disconnect();
        };
    </script>
</body>
</html>